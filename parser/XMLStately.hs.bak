-- File generated by the BNF Converter (bnfc 2.9.4.1).

{-# LANGUAGE LambdaCase #-}

-- Pretty printing to XML

module XMLStately where

import Prelude
  ( Char, Double, Integer, String
  , (.), ($), (+), (++)
  )
import qualified Prelude as P
  ( Show(..), Int
  , concat, concatMap, replicate, unlines
  )

import AbsStately

-- the top-level printing method
printXML :: XPrint a => a -> String
printXML = render . prt 0

render :: [String] -> String
render = P.unlines

-- the printer class does the job
class XPrint a where
  prt :: P.Int -> a -> [String]
  prtList :: P.Int -> [a] -> [String]
  prtList = P.concatMap . prt

instance XPrint a => XPrint [a] where
  prt = prtList

tag, etag :: String -> String
tag t = "<" ++ t ++ ">"
etag t = "<" ++ t ++ "/>"

elemTok, elemTokS :: P.Show a => P.Int -> String -> a -> [String]
elemTok i t x = [P.replicate (i+i) ' ' ++ tag (t ++ " value = " ++ P.show x ++ " /")]
elemTokS i t x = elemTok i t (P.show x)

elemFun :: P.Int -> String -> String -> [String]
elemFun i _ x = [P.replicate (i+i) ' ' ++ tag x]

endtag :: String -> String -> String
endtag f _ = tag ("/" ++ f)


instance XPrint Integer where
  prt i x = elemTokS i "Integer" x

instance XPrint Double where
  prt i x = elemTokS i "Double" x

instance XPrint Char where
  prt i x = elemTokS i "Char" x

  prtList i xs = elemTok i "String" xs
instance XPrint Ident where
  prt i (Ident x) = elemTok i "Ident" x


instance XPrint Stm where
  prt i' = \case
   Assign ident exp -> P.concat $  elemFun i' "Stm" "Assign" : prt (i'+1) ident : prt (i'+1) exp : [[P.replicate (i'+i') ' ' ++ endtag "Assign" "Stm"]]
   Block stms -> P.concat $  elemFun i' "Stm" "Block" : prt (i'+1) stms : [[P.replicate (i'+i') ' ' ++ endtag "Block" "Stm"]]
   While exp stm -> P.concat $  elemFun i' "Stm" "While" : prt (i'+1) exp : prt (i'+1) stm : [[P.replicate (i'+i') ' ' ++ endtag "While" "Stm"]]
   If exp stm0 stm -> P.concat $  elemFun i' "Stm" "If" : prt (i'+1) exp : prt (i'+1) stm0 : prt (i'+1) stm : [[P.replicate (i'+i') ' ' ++ endtag "If" "Stm"]]
   EAction action -> P.concat $  elemFun i' "Stm" "EAction" : prt (i'+1) action : [[P.replicate (i'+i') ' ' ++ endtag "EAction" "Stm"]]

instance XPrint Exp where
  prt i' = \case
   EVal val -> P.concat $  elemFun i' "Exp" "EVal" : prt (i'+1) val : [[P.replicate (i'+i') ' ' ++ endtag "EVal" "Exp"]]
   ETask val0 val -> P.concat $  elemFun i' "Exp" "ETask" : prt (i'+1) val0 : prt (i'+1) val : [[P.replicate (i'+i') ' ' ++ endtag "ETask" "Exp"]]

instance XPrint Val where
  prt i' = \case
   VString string -> P.concat $  elemFun i' "Val" "VString" : prt (i'+1) string : [[P.replicate (i'+i') ' ' ++ endtag "VString" "Val"]]
   VNumber integer -> P.concat $  elemFun i' "Val" "VNumber" : prt (i'+1) integer : [[P.replicate (i'+i') ' ' ++ endtag "VNumber" "Val"]]
   VBoolean boolean -> P.concat $  elemFun i' "Val" "VBoolean" : prt (i'+1) boolean : [[P.replicate (i'+i') ' ' ++ endtag "VBoolean" "Val"]]

instance XPrint Boolean where
  prt i' = \case
   BTrue  -> P.concat $  elemFun i' "Boolean" "BTrue"  : [[P.replicate (i'+i') ' ' ++ endtag "BTrue" "Boolean"]]
   BFalse  -> P.concat $  elemFun i' "Boolean" "BFalse"  : [[P.replicate (i'+i') ' ' ++ endtag "BFalse" "Boolean"]]

instance XPrint Action where
  prt i' = \case
   AWait val -> P.concat $  elemFun i' "Action" "AWait" : prt (i'+1) val : [[P.replicate (i'+i') ' ' ++ endtag "AWait" "Action"]]
   AFail  -> P.concat $  elemFun i' "Action" "AFail"  : [[P.replicate (i'+i') ' ' ++ endtag "AFail" "Action"]]
   ASucc  -> P.concat $  elemFun i' "Action" "ASucc"  : [[P.replicate (i'+i') ' ' ++ endtag "ASucc" "Action"]]


